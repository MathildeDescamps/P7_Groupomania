{"ast":null,"code":"const {\n  Readable\n} = require('stream');\n/**\n * @type {WeakMap<Blob, {type: string, size: number, parts: (Blob | Buffer)[] }>}\n */\n\n\nconst wm = new WeakMap();\n\nasync function* read(parts) {\n  for (const part of parts) {\n    if ('stream' in part) {\n      yield* part.stream();\n    } else {\n      yield part;\n    }\n  }\n}\n\nclass Blob {\n  /**\n   * The Blob() constructor returns a new Blob object. The content\n   * of the blob consists of the concatenation of the values given\n   * in the parameter array.\n   *\n   * @param {(ArrayBufferLike | ArrayBufferView | Blob | Buffer | string)[]} blobParts\n   * @param {{ type?: string }} [options]\n   */\n  constructor(blobParts = [], options = {\n    type: ''\n  }) {\n    let size = 0;\n    const parts = blobParts.map(element => {\n      let buffer;\n\n      if (element instanceof Buffer) {\n        buffer = element;\n      } else if (ArrayBuffer.isView(element)) {\n        buffer = Buffer.from(element.buffer, element.byteOffset, element.byteLength);\n      } else if (element instanceof ArrayBuffer) {\n        buffer = Buffer.from(element);\n      } else if (element instanceof Blob) {\n        buffer = element;\n      } else {\n        buffer = Buffer.from(typeof element === 'string' ? element : String(element));\n      }\n\n      size += buffer.length || buffer.size || 0;\n      return buffer;\n    });\n    const type = options.type === undefined ? '' : String(options.type).toLowerCase();\n    wm.set(this, {\n      type: /[^\\u0020-\\u007E]/.test(type) ? '' : type,\n      size,\n      parts\n    });\n  }\n  /**\n   * The Blob interface's size property returns the\n   * size of the Blob in bytes.\n   */\n\n\n  get size() {\n    return wm.get(this).size;\n  }\n  /**\n   * The type property of a Blob object returns the MIME type of the file.\n   */\n\n\n  get type() {\n    return wm.get(this).type;\n  }\n  /**\n   * The text() method in the Blob interface returns a Promise\n   * that resolves with a string containing the contents of\n   * the blob, interpreted as UTF-8.\n   *\n   * @return {Promise<string>}\n   */\n\n\n  async text() {\n    return Buffer.from(await this.arrayBuffer()).toString();\n  }\n  /**\n   * The arrayBuffer() method in the Blob interface returns a\n   * Promise that resolves with the contents of the blob as\n   * binary data contained in an ArrayBuffer.\n   *\n   * @return {Promise<ArrayBuffer>}\n   */\n\n\n  async arrayBuffer() {\n    const data = new Uint8Array(this.size);\n    let offset = 0;\n\n    for await (const chunk of this.stream()) {\n      data.set(chunk, offset);\n      offset += chunk.length;\n    }\n\n    return data.buffer;\n  }\n  /**\n   * The Blob interface's stream() method is difference from native\n   * and uses node streams instead of whatwg streams.\n   *\n   * @returns {Readable} Node readable stream\n   */\n\n\n  stream() {\n    return Readable.from(read(wm.get(this).parts));\n  }\n  /**\n   * The Blob interface's slice() method creates and returns a\n   * new Blob object which contains data from a subset of the\n   * blob on which it's called.\n   *\n   * @param {number} [start]\n   * @param {number} [end]\n   * @param {string} [type]\n   */\n\n\n  slice(start = 0, end = this.size, type = '') {\n    const {\n      size\n    } = this;\n    let relativeStart = start < 0 ? Math.max(size + start, 0) : Math.min(start, size);\n    let relativeEnd = end < 0 ? Math.max(size + end, 0) : Math.min(end, size);\n    const span = Math.max(relativeEnd - relativeStart, 0);\n    const parts = wm.get(this).parts.values();\n    const blobParts = [];\n    let added = 0;\n\n    for (const part of parts) {\n      const size = ArrayBuffer.isView(part) ? part.byteLength : part.size;\n\n      if (relativeStart && size <= relativeStart) {\n        // Skip the beginning and change the relative\n        // start & end position as we skip the unwanted parts\n        relativeStart -= size;\n        relativeEnd -= size;\n      } else {\n        const chunk = part.slice(relativeStart, Math.min(size, relativeEnd));\n        blobParts.push(chunk);\n        added += ArrayBuffer.isView(chunk) ? chunk.byteLength : chunk.size;\n        relativeStart = 0; // All next sequental parts should start at 0\n        // don't add the overflow to new blobParts\n\n        if (added >= span) {\n          break;\n        }\n      }\n    }\n\n    const blob = new Blob([], {\n      type\n    });\n    Object.assign(wm.get(blob), {\n      size: span,\n      parts: blobParts\n    });\n    return blob;\n  }\n\n  get [Symbol.toStringTag]() {\n    return 'Blob';\n  }\n\n  static [Symbol.hasInstance](object) {\n    return typeof object === 'object' && typeof object.stream === 'function' && object.stream.length === 0 && typeof object.constructor === 'function' && /^(Blob|File)$/.test(object[Symbol.toStringTag]);\n  }\n\n}\n\nObject.defineProperties(Blob.prototype, {\n  size: {\n    enumerable: true\n  },\n  type: {\n    enumerable: true\n  },\n  slice: {\n    enumerable: true\n  }\n});\nmodule.exports = Blob;","map":{"version":3,"sources":["/Users/mathildedescamps/Git/OpenClassrooms/P7/frontend/my-app/node_modules/fetch-blob/index.js"],"names":["Readable","require","wm","WeakMap","read","parts","part","stream","Blob","constructor","blobParts","options","type","size","map","element","buffer","Buffer","ArrayBuffer","isView","from","byteOffset","byteLength","String","length","undefined","toLowerCase","set","test","get","text","arrayBuffer","toString","data","Uint8Array","offset","chunk","slice","start","end","relativeStart","Math","max","min","relativeEnd","span","values","added","push","blob","Object","assign","Symbol","toStringTag","hasInstance","object","defineProperties","prototype","enumerable","module","exports"],"mappings":"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","sourcesContent":["const {Readable} = require('stream');\n\n/**\n * @type {WeakMap<Blob, {type: string, size: number, parts: (Blob | Buffer)[] }>}\n */\nconst wm = new WeakMap();\n\nasync function * read(parts) {\n\tfor (const part of parts) {\n\t\tif ('stream' in part) {\n\t\t\tyield * part.stream();\n\t\t} else {\n\t\t\tyield part;\n\t\t}\n\t}\n}\n\nclass Blob {\n\t/**\n\t * The Blob() constructor returns a new Blob object. The content\n\t * of the blob consists of the concatenation of the values given\n\t * in the parameter array.\n\t *\n\t * @param {(ArrayBufferLike | ArrayBufferView | Blob | Buffer | string)[]} blobParts\n\t * @param {{ type?: string }} [options]\n\t */\n\tconstructor(blobParts = [], options = {type: ''}) {\n\t\tlet size = 0;\n\n\t\tconst parts = blobParts.map(element => {\n\t\t\tlet buffer;\n\t\t\tif (element instanceof Buffer) {\n\t\t\t\tbuffer = element;\n\t\t\t} else if (ArrayBuffer.isView(element)) {\n\t\t\t\tbuffer = Buffer.from(element.buffer, element.byteOffset, element.byteLength);\n\t\t\t} else if (element instanceof ArrayBuffer) {\n\t\t\t\tbuffer = Buffer.from(element);\n\t\t\t} else if (element instanceof Blob) {\n\t\t\t\tbuffer = element;\n\t\t\t} else {\n\t\t\t\tbuffer = Buffer.from(typeof element === 'string' ? element : String(element));\n\t\t\t}\n\n\t\t\tsize += buffer.length || buffer.size || 0;\n\t\t\treturn buffer;\n\t\t});\n\n\t\tconst type = options.type === undefined ? '' : String(options.type).toLowerCase();\n\n\t\twm.set(this, {\n\t\t\ttype: /[^\\u0020-\\u007E]/.test(type) ? '' : type,\n\t\t\tsize,\n\t\t\tparts\n\t\t});\n\t}\n\n\t/**\n\t * The Blob interface's size property returns the\n\t * size of the Blob in bytes.\n\t */\n\tget size() {\n\t\treturn wm.get(this).size;\n\t}\n\n\t/**\n\t * The type property of a Blob object returns the MIME type of the file.\n\t */\n\tget type() {\n\t\treturn wm.get(this).type;\n\t}\n\n\t/**\n\t * The text() method in the Blob interface returns a Promise\n\t * that resolves with a string containing the contents of\n\t * the blob, interpreted as UTF-8.\n\t *\n\t * @return {Promise<string>}\n\t */\n\tasync text() {\n\t\treturn Buffer.from(await this.arrayBuffer()).toString();\n\t}\n\n\t/**\n\t * The arrayBuffer() method in the Blob interface returns a\n\t * Promise that resolves with the contents of the blob as\n\t * binary data contained in an ArrayBuffer.\n\t *\n\t * @return {Promise<ArrayBuffer>}\n\t */\n\tasync arrayBuffer() {\n\t\tconst data = new Uint8Array(this.size);\n\t\tlet offset = 0;\n\t\tfor await (const chunk of this.stream()) {\n\t\t\tdata.set(chunk, offset);\n\t\t\toffset += chunk.length;\n\t\t}\n\n\t\treturn data.buffer;\n\t}\n\n\t/**\n\t * The Blob interface's stream() method is difference from native\n\t * and uses node streams instead of whatwg streams.\n\t *\n\t * @returns {Readable} Node readable stream\n\t */\n\tstream() {\n\t\treturn Readable.from(read(wm.get(this).parts));\n\t}\n\n\t/**\n\t * The Blob interface's slice() method creates and returns a\n\t * new Blob object which contains data from a subset of the\n\t * blob on which it's called.\n\t *\n\t * @param {number} [start]\n\t * @param {number} [end]\n\t * @param {string} [type]\n\t */\n\tslice(start = 0, end = this.size, type = '') {\n\t\tconst {size} = this;\n\n\t\tlet relativeStart = start < 0 ? Math.max(size + start, 0) : Math.min(start, size);\n\t\tlet relativeEnd = end < 0 ? Math.max(size + end, 0) : Math.min(end, size);\n\n\t\tconst span = Math.max(relativeEnd - relativeStart, 0);\n\t\tconst parts = wm.get(this).parts.values();\n\t\tconst blobParts = [];\n\t\tlet added = 0;\n\n\t\tfor (const part of parts) {\n\t\t\tconst size = ArrayBuffer.isView(part) ? part.byteLength : part.size;\n\t\t\tif (relativeStart && size <= relativeStart) {\n\t\t\t\t// Skip the beginning and change the relative\n\t\t\t\t// start & end position as we skip the unwanted parts\n\t\t\t\trelativeStart -= size;\n\t\t\t\trelativeEnd -= size;\n\t\t\t} else {\n\t\t\t\tconst chunk = part.slice(relativeStart, Math.min(size, relativeEnd));\n\t\t\t\tblobParts.push(chunk);\n\t\t\t\tadded += ArrayBuffer.isView(chunk) ? chunk.byteLength : chunk.size;\n\t\t\t\trelativeStart = 0; // All next sequental parts should start at 0\n\n\t\t\t\t// don't add the overflow to new blobParts\n\t\t\t\tif (added >= span) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tconst blob = new Blob([], {type});\n\t\tObject.assign(wm.get(blob), {size: span, parts: blobParts});\n\n\t\treturn blob;\n\t}\n\n\tget [Symbol.toStringTag]() {\n\t\treturn 'Blob';\n\t}\n\n\tstatic [Symbol.hasInstance](object) {\n\t\treturn (\n\t\t\ttypeof object === 'object' &&\n\t\t\ttypeof object.stream === 'function' &&\n\t\t\tobject.stream.length === 0 &&\n\t\t\ttypeof object.constructor === 'function' &&\n\t\t\t/^(Blob|File)$/.test(object[Symbol.toStringTag])\n\t\t);\n\t}\n}\n\nObject.defineProperties(Blob.prototype, {\n\tsize: {enumerable: true},\n\ttype: {enumerable: true},\n\tslice: {enumerable: true}\n});\n\nmodule.exports = Blob;\n"]},"metadata":{},"sourceType":"script"}